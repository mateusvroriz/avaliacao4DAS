Seguindo o texto de  Spagnoli e Becker (2003), o modelo de componentes procura definir uma composição uniforme de cada componente de maneira que ambos os componentes saibam o que o outro está provendo. Além disto, o modelo de componentes também é responsável por definir a forma de interação entre componentes num framework. No JavaRMI, este comportamento é similar ao funcionamento de marshalling e unmarshalling, já que é a maneira pela qual o a máquina local se comunica com o objeto remoto.

Ainda de acordo com o texto de Spagnoli e Becker (2003), o framework de componentes é aquele no qual os padrões definidos no modelo de componentes são executados. O papel do framework é prestar suporte a comunicação entre componentes e gerenciar os recursos necessários a eles. Da mesma forma, no JavaRMI, stubs implementam a comunicação entre a máquina local e o servidor, realizando o marshalling de chamadas de referências em chamadas remotas para o servidor. O skeleton fica do outro lado da chamada enviada pelo stub, sendo também parte da implementação da comunicação definida no modelo de componentes, onde ele é responsável pelo unmarshalling dos argumentos e invoca a implementação do metodo do servidor.

O registro, utilizado no JavaRMI para nomear os objetos remotods na rede, também realiza um papel similar, prestando suporte a esta comunicação, podendo ser considerado um serviço de coordenação e, portanto, fazendo também parte do framework de componentes.

As classes utilizadas na máquina local e o objeto remoto, ou seja, as classes que compõem o cliente e as classes que compõem o servidor, são os componentes presentes na arquitetura JavaRMI. Este conjunto de classes é identificável, sendo construídos com seu uso no JavaRMI em mente. Além disto, eles tem interfaces explícitas para a comunicação via serialização e desserialização por meio de stubs e skeletons, e podem ser utilizados de maneira independete ou em conjunto.

*Resolvemos classificar servidor e cliente como componentes de software tendo em vista que stubs e skeletons não são independentes, o que é uma das características de componentes propostas pelos autores mencionados acima, ainda seguindo os critérios propostos por esses autores, consideremos que registro auxilia na comunicação entre componentes portanto deveria ser um framework e finalmente o processo de serialização(Marshalling e Unmarshalling) se encaixam melhor como modelo de software já que definem o comportamento e a forma de interação dos componentes.
